# -*- coding: utf-8 -*-
"""Untitled6.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17rG1qkhn3NXPYdkgOC3dx5nODSTrE7SP
"""

import torch

def hello():
  """
  This is a sample function that we will try to import and run to ensure that
  our environment is correctly set up on Google Colab.
  """
  print('Hello from pytorch101.py!')

hello()

def create_sample_tensor():
  """
  Return a torch Tensor of shape (3, 2) which is filled with zeros, except for        3,2 사이즈의 zero tensor 생성, (0,1)을 10으로 바꾸고 (1,0)을 100으로 
  element (0, 1) which is set to 10 and element (1, 0) which is set to 100.

  Inputs: None

  Returns:
  - Tensor of shape (3, 2) as described above.
  """
  x = None
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  x = None
  x = torch.zeros(3,2)
  x[1, 0] = 100
  x[0, 1] = 10
  pass                                                       
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return x

create_sample_tensor()

def mutate_tensor(x, indices, values):
  """
  Mutate the PyTorch tensor x according to indices and values.
  Specifically, indices is a list [(i0, j0), (i1, j1), ... ] of integer indices,           튜플과 리스트를 사용하여 x를 생성
  and values is a list [v0, v1, ...] of values. This function should mutate x
  by setting:

  x[i0, j0] = v0
  x[i1, j1] = v1

  and so on.

  If the same index pair appears multiple times in indices, you should set x to
  the last one.

  Inputs:
  - x: A Tensor of shape (H, W)
  - indicies: A list of N tuples [(i0, j0), (i1, j1), ..., ]
  - values: A list of N values [v0, v1, ...]

  Returns:
  - The input tensor x
  """

    


  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  for i, value in enumerate(indices):
    x[value[0],value[1]]=values[i]
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return x

indices = [(0,0),(1,0),(0,1),(1,1)]
values = [4,5,6,7]
x=torch.empty(2,2)
mutate_tensor(x, indices, values)

def count_tensor_elements(x):
  """
  Count the number of scalar elements in a tensor x.

  For example, a tensor of shape (10,) has 10 elements.a tensor of shape (3, 4)      텐서 x에 들어가있는 요소의 개수 세기
  has 12 elements; a tensor of shape (2, 3, 4) has 24 elements, etc.

  You may not use the functions torch.numel or x.numel. The input tensor should 
  not be modified.

  Inputs:
  - x: A tensor of any shape

  Returns:
  - num_elements: An integer giving the number of scalar elements in x
  """
  num_elements = None
  
  #############################################################################
  #                    TODO: Implement this function                          #
  #   You CANNOT use the built-in functions torch.numel(x) or x.numel().      #
  #############################################################################
  # Replace "pass" statement with your code
  num_elements = 1
  for i in x.size():
    num_elements = num_elements*1*i
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return num_elements

x=torch.rand(2)
count_tensor_elements(x)

def create_tensor_of_pi(M, N):
  """
  Returns a Tensor of shape (M, N) filled entirely with the value 3.14                  3.14로 채우기

  Inputs:
  - M, N: Positive integers giving the shape of Tensor to create

  Returns:
  - x: A tensor of shape (M, N) filled with the value 3.14
  """
  
  #############################################################################
  #       TODO: Implement this function. It should take one line.             #
  #############################################################################
  # Replace "pass" statement with your code
  x = torch.full((M, N), 3.14)
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return x

x = create_tensor_of_pi(4, 5)

def multiples_of_ten(start, stop):
  """
  Returns a Tensor of dtype torch.float64 that contains all of the multiples of
  ten (in order) between start and stop, inclusive. If there are no multiples           # 10의 배수 텐서 생성
  of ten in this range you should return an empty tensor of shape (0,).

  Inputs:
  - start, stop: Integers with start <= stop specifying the range to create.

  Returns:
  - x: Tensor of dtype float64 giving multiples of ten between start and stop.
  """
  assert start <= stop , "오류메세지"                                                              # assert 뒤에 조건 문제가 없다면 실행 잇다면 오류  
  x = None
     
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  x=torch.arange((start+9)//10 *10,stop,10, dtype=torch.float64)                                    #    10으로나눈 몫  *10
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return x

multiples_of_ten(120,169)

def slice_indexing_practice(x):
  """
  Given a two-dimensional tensor x, extract and return several subtensors to
  practice with slice indexing. Each tensor should be created using a single
  slice indexing operation.

  The input tensor should not be modified.

  Input:
  - x: Tensor of shape (M, N) -- M rows, N columns with M >= 3 and N >= 5.

  Returns a tuple of:
  - last_row: Tensor of shape (N,) giving the last row of x. It should be a                      x의 마지막 행이 
    one-dimensional tensor.
  - third_col: Tensor of shape (M, 1) giving the third column of x.                              x의 세번째 열 2차원
    It should be a two-dimensional tensor.
  - first_two_rows_three_cols: Tensor of shape (2, 3) giving the data in the                      x의 2행부터 3열
    first two rows and first three columns of x.
  - even_rows_odd_cols: Two-dimensional tensor containing the elements in the                   x의 짝수 행과 홀수 열
    even-valued rows and odd-valued columns of x.
  """
  assert x.shape[0] >= 3
  assert x.shape[1] >= 5
  last_row = None
  third_col = None
  first_two_rows_three_cols = None
  even_rows_odd_cols = None                                             
   #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  last_row = x[-1,:]
  third_col = x[:,[2]]                                                                     ### 2차원 []  
  first_two_rows_three_cols = x[0:2, 0:3]
  even_rows_odd_cols = x[::2, 1::2]                          
  out = (last_row, third_col, first_two_rows_three_cols, even_rows_odd_cols)
  return out

a = torch.rand(7, 10)
slice_indexing_practice(a)

def slice_assignment_practice(x):
  """
  Given a two-dimensional tensor of shape (M, N) with M >= 4, N >= 6, mutate its
  first 4 rows and 6 columns so they are equal to:

  [0 1 2 2 2 2]
  [0 1 2 2 2 2]                                                                     다음과 같이 텐서를 변경
  [3 4 3 4 5 5]
  [3 4 3 4 5 5]

  Your implementation must obey the following:              
  - You should mutate the tensor x in-place and return it
  - You should only modify the first 4 rows and first 6 columns; all other
    elements should remain unchanged
  - You may only mutate the tensor using slice assignment operations, where you
    assign an integer to a slice of the tensor
  - You must use <= 6 slicing operations to achieve the desired result

  Inputs:
  - x: A tensor of shape (M, N) with M >= 4 and N >= 6

  Returns: x
  """
  x[:2,0] = 0
  x[:2,1] = 1
  x[:2,2:] = 2
  x[2:,0:3:2] = 3
  x[2:,1:4:2] = 4
  x[2:,4:] = 5

  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return x

a = torch.ones(4,6, dtype=torch.int32)
slice_assignment_practice(a)

def shuffle_cols(x):
  """
  Re-order the columns of an input tensor as described below.

  Your implementation should construct the output tensor using a single integer
  array indexing operation. The input tensor should not be modified.

  Input:
  - x: A tensor of shape (M, N) with N >= 3

  Returns: A tensor y of shape (M, 4) where:
  - The first two columns of y are copies of the first column of x                  y의 1,2열은 x의 1열     
  - The third column of y is the same as the third column of x                      y의 3열은 x의 3 열
  - The fourth column of y is the same as the second column of x                    y의 4열은 x의 2 열 
  """
  y = None
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  y = x[:,[0,0,2,1]]
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a=torch.rand(5,7, dtype=torch.float32)
shuffle_cols(a)

def reverse_rows(x):
  """
  Reverse the rows of the input tensor.

  Your implementation should construct the output tensor using a single integer
  array indexing operation. The input tensor should not be modified.

  Input:
  - x: A tensor of shape (M, N)

  Returns: A tensor y of shape (M, N) which is the same as x but with the rows      y는 x와 행이 거꾸로
           reversed; that is the first row of y is equal to the last row of x,
           the second row of y is equal to the second to last row of x, etc.
  """
  y = None
                                                                          
  #############################################################################                 
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  y = x[range(x.size(0)-1,-1,-1),:]
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a=torch.tensor([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
reverse_rows(a)

def take_one_elem_per_col(x):
    """
    Construct a new tensor by picking out one element from each column of the
    input tensor as described below.
    The input tensor should not be modified.
    Input:
    - x: A tensor of shape (M, N) with M >= 4 and N >= 3.
    Returns: A tensor y of shape (3,) such that:                                    y는 (3,0) 1차원 
    - The first element of y is the second element of the first column of x         y의 1요소 = x의 2행1열 
    - The second element of y is the first element of the second column of x      # y의 2요소 = x의 1행2열
    - The third element of y is the fourth element of the third column of x       # y의 3요소 = x의 4행3열  
    """
    y = None
    #############################################################################
    #                    TODO: Implement this function                          #
    #############################################################################
    # Replace "pass" statement with your code
    y = torch.tensor([a[1,0].item(), a[0,1].item(), a[3,2].item()])
    #############################################################################
    #                            END OF YOUR CODE                               #
    #############################################################################
    return y

a=torch.tensor([[1,2,3],[4,5,6],[7,8,9],[10,11,12]])
take_one_elem_per_col(a)

def make_one_hot(x):
  """
  Construct a tensor of one-hot-vectors from a list of Python integers.

  Input:
  - x: A list of N integers

  Returns:
  - y: A tensor of shape (N, C) and where C = 1 + max(x) is one more than the max                 y의 shape는 (x리스트의크기, x의요소중 가장큰 값 +1)   x[n]=c 일때 y[n,c]=1   나머지요소는 0
       value in x. The nth row of y is a one-hot-vector representation of x[n];
       In other words, if x[n] = c then y[n, c] = 1; all other elements of y are
       zeros. The dtype of y should be torch.float32.
  """
  y = None
  ###########################################################################
  #                    TODO:z Implement this function                          #
  #############################################################################
  # Replace "pass"statement with your code
  y = torch.zeros(len(x),max(x)+1, dtype=torch.float32)
  for i in range(len(x)):
    y[i,x[i]]=1
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a=[1,2,3,4,5,6,7,8,9]
make_one_hot(a)

def count_negative_entries(x):
  """
  Return the number of negative values in the input tensor x.

  Your implementation should perform only a single indexing operation on the
  input tensor. You should not use any explicit loops. The input tensor should
  not be modified.

  Input:
  - x: A tensor of any shape

  Returns:
  - num_neg: Integer giving the number of negative values in x                      x에 있는 음수의 수
  """
  num_neg = 0
  num_neg = x[x<0].size()[0]                                                      

  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return num_neg

a=torch.tensor([[-1,2,3],[-4,5,6],[7,-8,9],[10,11,-12]])
count_negative_entries(a)

def reshape_practice(x):
  """
  Given an input tensor of shape (24,), return a reshaped tensor y of shape
  (3, 8) such that

  y = [
    [x[0], x[1], x[2],  x[3],  x[12], x[13], x[14], x[15]],
    [x[4], x[5], x[6],  x[7],  x[16], x[17], x[18], x[19]],
    [x[8], x[9], x[10], x[11], x[20], x[21], x[22], x[23]],
  ]

  You must construct y by performing a sequence of reshaping operations on x
  (view, t, transpose, permute, contiguous, reshape, etc). The input tensor
  should not be modified.

  Input:
  - x: A tensor of shape (24,)

  Returns:
  - y: A reshaped version of x of shape (3, 8) as described above.
  """
  y = None
  
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  y=x.reshape(3,-1)
  #y=x.view(3,-1)
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a=torch.rand(24)
reshape_practice(a)

def zero_row_min(x):
  """
  Return a copy of x, where the minimum value along each row has been set to 0.                inputx의 각 행 최소를 0으로

  For example, if x is:
  x = torch.tensor([[
        [10, 20, 30],
        [ 2,  5,  1]
      ]])

  Then y = zero_row_min(x) should be:
  torch.tensor([
    [0, 20, 30],
    [2,  5,  0]
  ])

  Your implementation should use reduction and indexing operations; you should
  not use any explicit loops. The input tensor should not be modified.

  Inputs:
  - x: Tensor of shape (M, N)

  Returns:
  - y: Tensor of shape (M, N) that is a copy of x, except the minimum value
       along each row is replaced with 0.
  """
  y = None
  
  
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  y=x
  col_min_vlas, col_min_idxs = x.min(dim=1)                                               #해당 행에서 가장작은 수치와 , 인덱스 번호 반환
  y[range(0,a.size(0)),col_min_idxs] = 0
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a = torch.tensor([
        [10, 20, 30],
        [ 2,  5,  1]
      ])
zero_row_min(a)

def batched_matrix_multiply(x, y, use_loop=True):
  """
  Perform batched matrix multiplication between the tensor x of shape (B, N, M)
  and the tensor y of shape (B, M, P).

  If use_loop=True, then you should use an explicit loop over the batch               use_loop = True이면 z[i] = x[i] 행렬곱 y[i] 그것이 B차원만큼 
  dimension B. If loop=False, then you should instead compute the batched             아니라면 루프없이 x 행렬곱 y 
  matrix multiply without an explicit loop using a single PyTorch operator.

  Inputs:
  - x: Tensor of shape (B, N, M)
  - y: Tensor of shape (B, M, P)
  - use_loop: Whether to use an explicit Python loop.

  Hint: torch.stack, bmm

  Returns:
  - z: Tensor of shape (B, N, P) where z[i] of shape (N, P) is the result of
       matrix multiplication between x[i] of shape (N, M) and y[i] of shape
       (M, P). It should have the same dtype as x.
  """
  z = None
  B, N, M = x.shape
  B, M, P = y.shape

  
  
  


  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  if use_loop:

    z = torch.stack([x[i].mm(y[i]) for i in range(B)])
    return z

    #for i in range(B):
     # zi=torch.stack(x[i].mm(y[i]))
     # return z
  
  
  z = torch.bmm(x, y)
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return z

a=torch.rand(3,4,5)
b=torch.rand(3,5,6)
batched_matrix_multiply(a, b, use_loop=True)

def normalize_columns(x):
  """
  Normalize the columns of the matrix x by subtracting the mean and dividing
  by standard deviation of each column. You should return a new tensor; the
  input should not be modified.

  More concretely, given an input tensor x of shape (M, N), produce an output
  tensor y of shape (M, N) where y[i, j] = (x[i, j] - mu_j) / sigma_j, where             y[i,j]는  j열기준으로 정규화 
  mu_j is the mean of the column x[:, j].

  Your implementation should not use any explicit Python loops (including
  list/set/etc comprehensions); you may only use basic arithmetic operations on
  tensors (+, -, *, /, **, sqrt), the sum reduction function, and reshape
  operations to facilitate broadcasting. You should not use torch.mean,
  torch.std, or their instance method variants x.mean, x.std.

  Input:
  - x: Tensor of shape (M, N).

  Returns:
  - y: Tensor of shape (M, N) as described above. It should have the same dtype
    as the input x.
  """
  y = None
  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  y=x
  for i in range(x.size(0)):
    for j in range(x.size(1)):
      y[i,j] = (x[i,j]-x.mean(axis=0)[j])/x.std(axis=0)[j]                            #행기준
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

a=torch.tensor([[1,2,3],[4,5,6],[7,8,9],[10,11,12]], dtype=torch.float32)
normalize_columns(a)

def mm_on_gpu(x, w):
  """
  Perform matrix multiplication on GPU

  Specifically, you should (i) place each input on GPU first, and then
  (ii) perform the matrix multiplication operation. Finally, (iii) return the
  final result, which is on CPU for a fair in-place replacement with the mm_on_cpu.

  When you move the tensor to GPU, PLEASE use "your_tensor_intance.cuda()" operation.

  Input:
  - x: Tensor of shape (A, B), on CPU
  - w: Tensor of shape (B, C), on CPU

  Returns:
  - y: Tensor of shape (A, C) as described above. It should not be in GPU.
  """
  y = None

  #############################################################################
  #                    TODO: Implement this function                          #
  #############################################################################
  # Replace "pass" statement with your code
  if torch.cuda.is_available:
        x = x.cuda()
        w = w.cuda()
        return x.mm(w).cpu()

  y = x.mm(w)
  pass
  #############################################################################
  #                            END OF YOUR CODE                               #
  #############################################################################
  return y

